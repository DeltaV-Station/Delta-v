using System.Linq;
using Content.Shared._DV.Traits;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;

namespace Content.Client._DV.Traits.UI;

[GenerateTypedNameReferences]
public sealed partial class TraitCategory : BoxContainer
{
    public event Action<ProtoId<TraitPrototype>, bool>? OnTraitToggled;

    private readonly TraitCategoryPrototype _category;
    private readonly List<TraitPrototype> _allTraits;
    private readonly Dictionary<ProtoId<TraitPrototype>, TraitEntry> _traitEntries = new();

    private bool _isExpanded;

    public int SelectedCount;
    public int PointsSpent;

    public TraitCategory(TraitCategoryPrototype category, List<TraitPrototype> traits)
    {
        RobustXamlLoader.Load(this);

        _category = category;
        _allTraits = traits;
        _isExpanded = category.DefaultExpanded;

        CategoryNameLabel.Text = Loc.GetString(category.Name);
        SetAccentColor(category.AccentColor);

        HeaderButton.OnPressed += _ => ToggleExpanded();

        PopulateTraits();
        UpdateExpandedState();
        UpdateStats();
    }

    private void SetAccentColor(Color color)
    {
        AccentBar.PanelOverride = new StyleBoxFlat { BackgroundColor = color }; // dumb stylesheet modulation workaround
    }

    private void PopulateTraits()
    {
        TraitsContainer.RemoveAllChildren();
        _traitEntries.Clear();

        foreach (var trait in _allTraits)
        {
            var entry = new TraitEntry(trait);
            entry.OnToggled += selected => OnTraitEntryToggled(trait.ID, selected);
            _traitEntries[trait.ID] = entry;
            TraitsContainer.AddChild(entry);
        }
    }

    private void OnTraitEntryToggled(ProtoId<TraitPrototype> traitId, bool selected)
    {
        OnTraitToggled?.Invoke(traitId, selected);
    }

    private void ToggleExpanded()
    {
        _isExpanded = !_isExpanded;
        UpdateExpandedState();
    }

    private void UpdateExpandedState()
    {
        ContentPanel.Visible = _isExpanded;
        ExpandIcon.Text = _isExpanded ? "▼" : "▶";
    }

    public void UpdateStats()
    {
        SelectedCount = _traitEntries.Values.Count(e => e.IsSelected);
        PointsSpent = _traitEntries.Values
            .Where(e => e.IsSelected)
            .Sum(e => e.TraitCost);

        if (_category.MaxTraits.HasValue)
        {
            CategoryStatsLabel.Text = Loc.GetString("trait-category-traits",
                ("selected", SelectedCount),
                ("max", _category.MaxTraits.Value));
        }
        else
        {
            CategoryStatsLabel.Text = Loc.GetString("trait-category-traits-unlimited",
                ("selected", SelectedCount));
        }

        if (_category.MaxPoints.HasValue)
        {
            CategoryPointsLabel.Visible = true;
            CategoryPointsLabel.Text = Loc.GetString("trait-category-points",
                ("selected", PointsSpent),
                ("max", _category.MaxPoints.Value));
        }
        else
        {
            CategoryPointsLabel.Visible = false;
        }
    }

    public void SetTraitSelected(ProtoId<TraitPrototype> traitId, bool selected)
    {
        if (_traitEntries.TryGetValue(traitId, out var entry))
        {
            entry.SetSelected(selected);
        }
    }

    public void ClearSelection()
    {
        foreach (var (_, entry) in _traitEntries)
        {
            entry.SetSelected(false);
        }

        SelectedCount = 0;
        PointsSpent = 0;
        UpdateStats();
    }

    /// <summary>
    /// Gets the IDs of all currently selected traits in this category.
    /// </summary>
    public IEnumerable<ProtoId<TraitPrototype>> GetSelectedTraitIds()
    {
        return _traitEntries
            .Where(kvp => kvp.Value.IsSelected)
            .Select(kvp => kvp.Key);
    }

    /// <summary>
    /// Filters traits based on search text only
    /// </summary>
    public void FilterTraits(string searchText)
    {
        var hasVisibleTraits = false;

        foreach (var (traitId, entry) in _traitEntries)
        {
            var trait = _allTraits.First(t => t.ID == traitId);
            var name = Loc.GetString(trait.Name);
            var description = Loc.GetString(trait.Description);

            var matchesSearch = string.IsNullOrEmpty(searchText) ||
                                name.Contains(searchText, StringComparison.OrdinalIgnoreCase) ||
                                description.Contains(searchText, StringComparison.OrdinalIgnoreCase);

            entry.Visible = matchesSearch;

            if (entry.Visible)
                hasVisibleTraits = true;
        }

        // Hide entire category if no traits match search
        Visible = hasVisibleTraits;
    }

    /// <summary>
    /// Updates condition states for all trait entries based on current job/species.
    /// Traits that don't meet conditions are disabled but still visible.
    /// </summary>
    public void UpdateConditions(string? jobId, string? speciesId)
    {
        foreach (var (_, entry) in _traitEntries)
        {
            entry.UpdateConditionsMet(jobId, speciesId);
        }

        // Update stats since some traits may have been deselected
        UpdateStats();
    }

    /// <summary>
    /// Checks if a trait in this category meets its conditions.
    /// </summary>
    public bool TraitMeetsConditions(ProtoId<TraitPrototype> traitId)
    {
        return _traitEntries.TryGetValue(traitId, out var entry) && entry.MeetsConditions;
    }
}
