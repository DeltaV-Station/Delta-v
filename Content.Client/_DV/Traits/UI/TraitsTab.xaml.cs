using System.Linq;
using Content.Shared._DV.CCVars;
using Content.Shared._DV.Traits;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Prototypes;

namespace Content.Client._DV.Traits.UI;

[GenerateTypedNameReferences]
public sealed partial class TraitsTab : BoxContainer
{
    [Dependency] private readonly IConfigurationManager _cfg = default!;
    [Dependency] private readonly IPrototypeManager _prototype = default!;

    /// <summary>
    /// Event fired when trait selection changes.
    /// </summary>
    public event Action<HashSet<ProtoId<TraitPrototype>>>? OnTraitsChanged;

    private readonly Dictionary<ProtoId<TraitCategoryPrototype>, TraitCategory> _categoryUis = new();
    private readonly HashSet<ProtoId<TraitPrototype>> _selectedTraits = new();

    private int _maxGlobalTraits;
    private int _maxGlobalPoints;
    private int _currentTraitCount;
    private int _currentPointsSpent;

    private string _currentSearchText = string.Empty;
    private bool _awaitingLayoutUpdate;

    public TraitsTab()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        SearchBar.OnTextChanged += OnSearchTextChanged;
        _prototype.PrototypesReloaded += OnProtoReload;

        // Subscribe to CVars
        _cfg.OnValueChanged(DCCVars.MaxTraitCount, OnMaxTraitCountChanged, true);
        _cfg.OnValueChanged(DCCVars.MaxTraitPoints, OnMaxTraitPointsChanged, true);

        PopulateCategories();
        UpdateGlobalStats();
    }

    private void OnMaxTraitCountChanged(int value)
    {
        _maxGlobalTraits = value;
        UpdateGlobalStats();
    }

    private void OnMaxTraitPointsChanged(int value)
    {
        _maxGlobalPoints = value;
        UpdateGlobalStats();
    }

    private void OnProtoReload(PrototypesReloadedEventArgs args)
    {
        // Don't refresh if control has been disposed
        if (Disposed)
            return;

        if (args.WasModified<TraitPrototype>() || args.WasModified<TraitCategoryPrototype>())
            RefreshTraits();
    }

    public void RefreshTraits()
    {
        PopulateCategories();
        UpdateGlobalStats();
    }

    private void PopulateCategories()
    {
        CategoriesContainer.RemoveAllChildren();
        _categoryUis.Clear();

        var categories = _prototype.EnumeratePrototypes<TraitCategoryPrototype>()
            .OrderBy(c => c.Priority)
            .ThenBy(c => Loc.GetString(c.Name))
            .ToList();

        var traitsByCategory = _prototype.EnumeratePrototypes<TraitPrototype>()
            .GroupBy(t => t.Category)
            .ToDictionary(g => g.Key, g => g.OrderBy(t => Loc.GetString(t.Name)).ToList());

        foreach (var category in categories)
        {
            if (!traitsByCategory.TryGetValue(category.ID, out var traits) || traits.Count == 0)
                continue;

            var categoryUi = new TraitCategory(category, traits);
            categoryUi.OnTraitToggled += OnTraitToggled;
            _categoryUis[category.ID] = categoryUi;
            CategoriesContainer.AddChild(categoryUi);
        }

        // Apply current filters and conditions
        ApplySearchFilter();
        UpdateAllConditions();
    }

    private void OnTraitToggled(ProtoId<TraitPrototype> traitId, bool selected)
    {
        var trait = _prototype.Index(traitId);

        if (selected)
        {
            // Check global limits
            if (_currentTraitCount >= _maxGlobalTraits)
            {
                RevertTraitToggle(traitId);
                return;
            }

            if (_currentPointsSpent + trait.Cost > _maxGlobalPoints)
            {
                RevertTraitToggle(traitId);
                return;
            }

            // Check category limits
            if (_categoryUis.TryGetValue(trait.Category, out var categoryUi))
            {
                var categoryProto = _prototype.Index(trait.Category);
                if (categoryProto.MaxTraits.HasValue &&
                    categoryUi.SelectedCount >= categoryProto.MaxTraits.Value)
                {
                    RevertTraitToggle(traitId);
                    return;
                }

                if (categoryProto.MaxPoints.HasValue &&
                    categoryUi.PointsSpent + trait.Cost > categoryProto.MaxPoints.Value)
                {
                    RevertTraitToggle(traitId);
                    return;
                }

                // Check if trait meets conditions
                if (!categoryUi.TraitMeetsConditions(traitId))
                {
                    RevertTraitToggle(traitId);
                    return;
                }
            }

            // Check conflicts
            foreach (var conflict in trait.Conflicts)
            {
                if (!_selectedTraits.Contains(conflict))
                    continue;

                RevertTraitToggle(traitId);
                return;
            }

            _selectedTraits.Add(traitId);
            _currentTraitCount++;
            _currentPointsSpent += trait.Cost;
        }
        else
        {
            _selectedTraits.Remove(traitId);
            _currentTraitCount--;
            _currentPointsSpent -= trait.Cost;
        }

        UpdateGlobalStats();
        UpdateCategoryStats(trait.Category);
        OnTraitsChanged?.Invoke(_selectedTraits);
    }

    private void RevertTraitToggle(ProtoId<TraitPrototype> traitId)
    {
        var trait = _prototype.Index(traitId);
        if (_categoryUis.TryGetValue(trait.Category, out var categoryUi))
        {
            categoryUi.SetTraitSelected(traitId, _selectedTraits.Contains(traitId));
        }
    }

    private void UpdateGlobalStats()
    {
        GlobalTraitCountLabel.Text = $"{_currentTraitCount} / {_maxGlobalTraits}";
        GlobalPointsLabel.Text = $"{_maxGlobalPoints - _currentPointsSpent} / {_maxGlobalPoints}";

        // Calculate remaining points (clamped to not go below 0 in display)
        var remainingPoints = _maxGlobalPoints - _currentPointsSpent;
        GlobalPointsLabel.Text = $"{remainingPoints} / {_maxGlobalPoints}";

        // Calculate progress bar percentage - clamp between 0 and 1
        var percentage = _maxGlobalPoints > 0
            ? Math.Clamp((float)remainingPoints / _maxGlobalPoints, 0f, 1f)
            : 0f;

        // Update progress bar using percentage-based sizing
        var parent = GlobalPointsBar.Parent;
        if (parent != null)
        {
            var parentWidth = parent.Width;
            // If parent width is 0 (not laid out yet), defer until layout happens
            if (parentWidth > 0)
            {
                GlobalPointsBar.SetWidth = (int)(parentWidth * percentage);
                _awaitingLayoutUpdate = false;
            }
            else if (!_awaitingLayoutUpdate)
            {
                // Schedule update after parent layout (only once)
                _awaitingLayoutUpdate = true;
                parent.OnResized += OnProgressBarParentResized;
            }
        }

        // Update progress bar color class
        GlobalPointsBar.RemoveStyleClass("TraitsProgressBarFull");
        GlobalPointsBar.RemoveStyleClass("TraitsProgressBarPartial");
        GlobalPointsBar.RemoveStyleClass("TraitsProgressBarLow");
        GlobalPointsBar.RemoveStyleClass("TraitsProgressBarEmpty");

        GlobalPointsBar.AddStyleClass(percentage switch
        {
            >= 0.99f => "TraitsProgressBarFull",
            >= 0.5f => "TraitsProgressBarPartial",
            > 0f => "TraitsProgressBarLow",
            _ => "TraitsProgressBarEmpty"
        });
    }

    private void OnProgressBarParentResized()
    {
        _awaitingLayoutUpdate = false;
        UpdateGlobalStats();
    }

    private void UpdateCategoryStats(ProtoId<TraitCategoryPrototype> categoryId)
    {
        if (_categoryUis.TryGetValue(categoryId, out var categoryUi))
        {
            categoryUi.UpdateStats();
        }
    }

    private void OnSearchTextChanged(LineEdit.LineEditEventArgs args)
    {
        _currentSearchText = args.Text.Trim();
        ApplySearchFilter();
    }

    private void ApplySearchFilter()
    {
        foreach (var (_, categoryUi) in _categoryUis)
        {
            categoryUi.FilterTraits(_currentSearchText);
        }
    }

    private void UpdateAllConditions()
    {
        RecalculateStats();
    }

    private void RecalculateStats()
    {
        _currentTraitCount = 0;
        _currentPointsSpent = 0;

        // Rebuild selected traits based on what's actually selected in the UI
        var previouslySelected = new HashSet<ProtoId<TraitPrototype>>(_selectedTraits);
        _selectedTraits.Clear();

        foreach (var (_, categoryUi) in _categoryUis)
        {
            // Get the selected traits from this category
            var selectedInCategory = categoryUi.GetSelectedTraitIds();

            foreach (var traitId in selectedInCategory)
            {
                if (!_prototype.TryIndex(traitId, out var trait))
                    continue;

                _selectedTraits.Add(traitId);
                _currentTraitCount++;
                _currentPointsSpent += trait.Cost;
            }
        }

        UpdateGlobalStats();
        foreach (var (categoryId, _) in _categoryUis)
        {
            UpdateCategoryStats(categoryId);
        }

        // Fire event if selection changed
        if (!_selectedTraits.SetEquals(previouslySelected))
        {
            OnTraitsChanged?.Invoke(_selectedTraits);
        }
    }

    /// <summary>
    /// Sets the currently selected traits (e.g., when loading a profile).
    /// </summary>
    public void SetSelectedTraits(IEnumerable<ProtoId<TraitPrototype>> traits)
    {
        // Clear current selection
        foreach (var (_, categoryUi) in _categoryUis)
        {
            categoryUi.ClearSelection();
        }

        _selectedTraits.Clear();
        _currentTraitCount = 0;
        _currentPointsSpent = 0;

        // Apply new selection
        foreach (var traitId in traits)
        {
            if (!_prototype.TryIndex(traitId, out var trait))
                continue;

            _selectedTraits.Add(traitId);
            _currentTraitCount++;
            _currentPointsSpent += trait.Cost;

            if (_categoryUis.TryGetValue(trait.Category, out var categoryUi))
            {
                categoryUi.SetTraitSelected(traitId, true);
            }
        }

        UpdateGlobalStats();
        foreach (var (categoryId, _) in _categoryUis)
        {
            UpdateCategoryStats(categoryId);
        }
    }
}
