// SPDX-FileCopyrightText: 2024 Skubman <ba.fallaria@gmail.com>
// SPDX-FileCopyrightText: 2024 Tadeo <td12233a@gmail.com>
// SPDX-FileCopyrightText: 2025 Evaisa <evagiacosa1@gmail.com>
// SPDX-FileCopyrightText: 2025 EvaisaDev <mail@evaisa.dev>
// SPDX-FileCopyrightText: 2025 Icepick <122653407+Icepicked@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 corresp0nd <46357632+corresp0nd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 taydeo <td12233a@gmail.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later AND MIT

using System.Linq;
using System.Numerics;
using Content.Shared._DV.CartridgeLoader.Cartridges;
using Content.Shared.CCVar;
using Content.Client._Funkystation.NanoChat;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.UserInterface;
using Robust.Shared.Configuration;
using Robust.Shared.Timing;
using Content.Shared.Input;

namespace Content.Client._DV.CartridgeLoader.Cartridges;

[GenerateTypedNameReferences]
public sealed partial class NanoChatUiFragment : BoxContainer
{
    [Dependency] private readonly IGameTiming _timing = default!;
    [Dependency] private readonly IConfigurationManager _cfg = default!;

    private readonly int _maxNameLength;
    private readonly int _maxIdJobLength;
    private readonly NewChatPopup _newChatPopup;
    private readonly EditChatPopup _editChatPopup;
    private readonly CreateGroupChatPopup _createGroupChatPopup;
    private readonly InviteToGroupPopup _inviteToGroupPopup;
    private readonly GroupMembersPopup _groupMembersPopup;
    private readonly EmojiPickerPopup _emojiPickerPopup;
    private uint? _currentChat;
    private uint? _pendingChat;
    private uint _ownNumber;
    private bool _notificationsMuted;
    private bool _listNumber = true;
    private Dictionary<uint, NanoChatRecipient> _recipients = [];
    private Dictionary<uint, List<NanoChatMessage>> _messages = [];
    private HashSet<uint> _mutedChats = [];
    private List<NanoChatRecipient>? _contacts; // Used in order to show names for people not in recipients

    public event Action<NanoChatUiMessageType, uint?, string?, string?>? OnMessageSent;

    public NanoChatUiFragment()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _maxNameLength = _cfg.GetCVar(CCVars.MaxNameLength);
        _maxIdJobLength = _cfg.GetCVar(CCVars.MaxIdJobLength);

        _newChatPopup = new(_maxNameLength, _maxIdJobLength);
        _editChatPopup = new(_maxNameLength, _maxIdJobLength);
        _createGroupChatPopup = new(_maxNameLength);
        _inviteToGroupPopup = new();
        _groupMembersPopup = new();
        _emojiPickerPopup = new();
        SetupEventHandlers();
    }

    private void SetupEventHandlers()
    {
        _newChatPopup.OnChatCreated += (number, name, job) =>
        {
            OnMessageSent?.Invoke(NanoChatUiMessageType.NewChat, number, name, job);
        };

        _editChatPopup.OnContactEdited += (number, name, job) =>
        {
            OnMessageSent?.Invoke(NanoChatUiMessageType.EditChat, number, name, job);
        };

        _createGroupChatPopup.OnGroupCreated += (name) =>
        {
            OnMessageSent?.Invoke(NanoChatUiMessageType.CreateGroupChat, null, name, null);
        };

        _inviteToGroupPopup.OnInvite += (number) =>
        {
            if (_currentChat is not uint currentChat)
                return;

            OnMessageSent?.Invoke(NanoChatUiMessageType.InviteToGroup, currentChat, number.ToString(), null);
        };

        _groupMembersPopup.OnKick += (number) =>
        {
            if (_currentChat is not uint currentChat)
                return;

            OnMessageSent?.Invoke(NanoChatUiMessageType.KickFromGroup, currentChat, number.ToString(), null);
        };

        _groupMembersPopup.OnAdmin += (number) =>
        {
            if (_currentChat is not uint currentChat)
                return;

            OnMessageSent?.Invoke(NanoChatUiMessageType.AdminUser, currentChat, number.ToString(), null);
        };

        _groupMembersPopup.OnDeadmin += (number) =>
        {
            if (_currentChat is not uint currentChat)
                return;

            OnMessageSent?.Invoke(NanoChatUiMessageType.DeadminUser, currentChat, number.ToString(), null);
        };

        _emojiPickerPopup.OnEmojiSelected += InsertEmoji;

        NewChatButton.OnPressed += _ =>
        {
            _newChatPopup.ClearInputs();
            _newChatPopup.OpenCentered();
        };

        CreateGroupChatButton.OnPressed += _ =>
        {
            _createGroupChatPopup.ClearInputs();
            _createGroupChatPopup.OpenCentered();
        };

        MuteChatButton.OnPressed += _ =>
        {
            if (_currentChat is not uint currentChat)
                return;

            // Remove if muted, otherwise add
            if (!_mutedChats.Remove(currentChat))
                _mutedChats.Add(currentChat);

            UpdateMuteChatButton();
            OnMessageSent?.Invoke(NanoChatUiMessageType.ToggleMuteChat, currentChat, null, null);
        };

        MuteButton.OnPressed += _ =>
        {
            _notificationsMuted = !_notificationsMuted;
            UpdateMuteButton();
            OnMessageSent?.Invoke(NanoChatUiMessageType.ToggleMute, null, null, null);
        };

        MessageInput.OnKeyBindDown += args =>
        {
            if (args.Function == ContentKeyFunctions.NanoChatNavigateUpUnread)
                CycleChannel(CycleDirection.Up, true);
            else if (args.Function == ContentKeyFunctions.NanoChatNavigateDownUnread)
                CycleChannel(CycleDirection.Down, true);
            else if (args.Function == ContentKeyFunctions.NanoChatNavigateUp)
                CycleChannel(CycleDirection.Up, false);
            else if (args.Function == ContentKeyFunctions.NanoChatNavigateDown)
                CycleChannel(CycleDirection.Down, false);
        };
        MessageInput.OnTextChanged += args =>
        {
            var length = args.Text.Length;
            var isValid = !string.IsNullOrWhiteSpace(args.Text) &&
                          length <= NanoChatMessage.MaxContentLength &&
                          (_currentChat != null || _pendingChat != null);

            SendButton.Disabled = !isValid;

            // Show character count when over limit
            CharacterCount.Visible = length > NanoChatMessage.MaxContentLength;
            if (length > NanoChatMessage.MaxContentLength)
            {
                CharacterCount.Text = Loc.GetString("nano-chat-message-too-long",
                    ("current", length),
                    ("max", NanoChatMessage.MaxContentLength));
                CharacterCount.StyleClasses.Add("LabelDanger");
            }
        };

        LookupButton.OnPressed += _ => ToggleView();
        LookupView.OnStartChat += contact =>
        {
            if (OnMessageSent is { } handler)
            {
                handler(NanoChatUiMessageType.NewChat, contact.Number, contact.Name, contact.JobTitle);
                SelectChat(contact.Number);
                ToggleView();
            }
        };
        ListNumberButton.OnPressed += _ =>
        {
            _listNumber = !_listNumber;
            UpdateListNumber();
            OnMessageSent?.Invoke(NanoChatUiMessageType.ToggleListNumber, null, null, null);
        };

        MessageInput.OnTextEntered += _ => SendMessage();
        SendButton.OnPressed += _ => SendMessage();
        EmojiButton.OnPressed += _ => OpenEmojiPicker();
        EditChatButton.OnPressed += _ => BeginEditChat();
        DeleteChatButton.OnPressed += _ => DeleteCurrentChat();
        InviteToGroupButton.OnPressed += _ => OpenInvitePopup();
        ViewMembersButton.OnPressed += _ => OpenMembersPopup();
    }

    private void OpenEmojiPicker()
    {
        // Close any existing emoji picker to prevent duplicates (shouldn't be happening anyway but it sure did)
        if (_emojiPickerPopup.IsOpen)
            _emojiPickerPopup.Close();

        _emojiPickerPopup.OpenCentered();
    }

    private void InsertEmoji(string emoji)
    {
        MessageInput.InsertAtCursor(emoji);
        MessageInput.GrabKeyboardFocus();
    }

    /// <summary>
    /// Closes all open popups. Called when switching apps or closing the PDA.
    /// </summary>
    public void CloseAllPopups()
    {
        _emojiPickerPopup.Close();
        _inviteToGroupPopup.Close();
        _groupMembersPopup.Close();
        _newChatPopup.Close();
        _editChatPopup.Close();
        _createGroupChatPopup.Close();
    }

    private void ToggleView()
    {
        ChatView.Visible = !ChatView.Visible;
        LookupView.Visible = !ChatView.Visible;
        LookupButton.Pressed = LookupView.Visible;
    }

    public enum CycleDirection : byte
    {
        Up,
        Down,
    };

    private void CycleChannel(CycleDirection direction, bool onlyUnread)
    {
        if (_recipients.Count == 0)
            return;

        var orderedRecipients = _recipients.OrderBy(r => r.Value).Select(r => r.Key).ToArray();
        var currentChatIndex = (direction, _currentChat) switch
        {
            (CycleDirection.Up, null) => _recipients.Count,
            (CycleDirection.Down, null) => 0,
            (_, uint currentChat) => Array.IndexOf(orderedRecipients, currentChat),
            _ => 0
        };
        var newChatIndex = currentChatIndex;

        do
        {
            newChatIndex = direction switch
            {
                CycleDirection.Up => newChatIndex - 1,
                CycleDirection.Down => newChatIndex + 1,
                _ => currentChatIndex,
            };
            if (newChatIndex < 0)
                newChatIndex = _recipients.Count - 1;
            else if (newChatIndex >= _recipients.Count)
                newChatIndex = 0;
        } while (onlyUnread && newChatIndex != currentChatIndex && !_recipients[orderedRecipients[newChatIndex]].HasUnread);

        SelectChat(orderedRecipients[newChatIndex]);
    }

    private void SendMessage()
    {
        var activeChat = _pendingChat ?? _currentChat;
        if (activeChat == null || string.IsNullOrWhiteSpace(MessageInput.Text))
            return;

        var messageContent = MessageInput.Text;
        if (!string.IsNullOrWhiteSpace(messageContent))
        {
            messageContent = messageContent.Trim();
            if (messageContent.Length > NanoChatMessage.MaxContentLength)
                messageContent = messageContent[..NanoChatMessage.MaxContentLength];
        }

        // Add predicted message
        var predictedMessage = new NanoChatMessage(
            _timing.CurTime,
            messageContent,
            _ownNumber
        );

        if (!_messages.TryGetValue(activeChat.Value, out var value))
        {
            value = new List<NanoChatMessage>();
            _messages[activeChat.Value] = value;
        }

        value.Add(predictedMessage);

        // Update UI with predicted message
        UpdateMessages(_messages);

        // Send message event
        OnMessageSent?.Invoke(NanoChatUiMessageType.SendMessage, activeChat, messageContent, null);

        // Clear input
        MessageInput.Text = string.Empty;
        SendButton.Disabled = true;
    }

    private void SelectChat(uint number)
    {
        // Don't reselect the same chat
        if (_currentChat == number && _pendingChat == null)
            return;

        _pendingChat = number;

        // Predict marking messages as read
        if (_recipients.TryGetValue(number, out var recipient))
        {
            recipient.HasUnread = false;
            _recipients[number] = recipient;
            UpdateChatList(_recipients);
        }

        OnMessageSent?.Invoke(NanoChatUiMessageType.SelectChat, number, null, null);
        UpdateCurrentChat();
    }

    private void DeleteCurrentChat()
    {
        var activeChat = _pendingChat ?? _currentChat;
        if (activeChat == null)
            return;

        OnMessageSent?.Invoke(NanoChatUiMessageType.DeleteChat, activeChat, null, null);
    }

    private void OpenInvitePopup()
    {
        if (_currentChat is not uint currentChat ||
            !_recipients.TryGetValue(currentChat, out var recipient) ||
            !recipient.IsGroup)
            return;

        var availableContacts = _contacts ?? new List<NanoChatRecipient>();
        var members = recipient.Members ?? new HashSet<uint>();
        _inviteToGroupPopup.SetContacts(availableContacts, members, _ownNumber);
        _inviteToGroupPopup.ClearSearch();
        _inviteToGroupPopup.OpenCentered();
    }

    private void OpenMembersPopup()
    {
        if (_currentChat is not uint currentChat ||
            !_recipients.TryGetValue(currentChat, out var recipient) ||
            !recipient.IsGroup)
            return;

        var availableContacts = _contacts ?? new List<NanoChatRecipient>();
        var members = recipient.Members ?? new HashSet<uint>();
        var admins = recipient.Admins ?? new HashSet<uint>();
        _groupMembersPopup.SetMembers(availableContacts, members, _ownNumber, recipient.CreatorId, admins);
        _groupMembersPopup.OpenCentered();
    }

    private void RefreshOpenPopups()
    {
        // If popup is open, refresh it or close if no longer a member
        if (_inviteToGroupPopup.IsOpen)
        {
            if (_currentChat is uint currentChat &&
                _recipients.TryGetValue(currentChat, out var recipient) &&
                recipient.IsGroup)
            {
                var members = recipient.Members ?? new HashSet<uint>();
                if (!members.Contains(_ownNumber))
                {
                    _inviteToGroupPopup.Close();
                }
                else
                {
                    // Use the contacts list from the server (same as Look Up Numbers)
                    // Don't fall back to recipients as they contain outdated cached information
                    var availableContacts = _contacts ?? new List<NanoChatRecipient>();
                    _inviteToGroupPopup.SetContacts(availableContacts, members, _ownNumber);
                }
            }
            else
            {
                _inviteToGroupPopup.Close();
            }
        }

        if (_groupMembersPopup.IsOpen)
        {
            if (_currentChat is uint currentChat &&
                _recipients.TryGetValue(currentChat, out var recipient) &&
                recipient.IsGroup)
            {
                var members = recipient.Members ?? new HashSet<uint>();
                if (!members.Contains(_ownNumber))
                {
                    _groupMembersPopup.Close();
                }
                else
                {
                    // Use the contacts list from the server (same as Look Up Numbers)
                    // Don't fall back to recipients as they contain outdated cached information
                    var availableContacts = _contacts ?? new List<NanoChatRecipient>();
                    var admins = recipient.Admins ?? new HashSet<uint>();
                    _groupMembersPopup.SetMembers(availableContacts, members, _ownNumber, recipient.CreatorId, admins);
                }
            }
            else
            {
                _groupMembersPopup.Close();
            }
        }
    }

    private void BeginEditChat()
    {
        if (_currentChat is not uint currentChat)
            return;

        var recipient = _recipients[currentChat];

        _editChatPopup.ClearInputs();
        _editChatPopup.SetNumberInput(recipient.Number.ToString());
        _editChatPopup.SetNameInput(recipient.Name);
        _editChatPopup.SetJobInput(recipient.JobTitle ?? string.Empty);
        _editChatPopup.OpenCentered();
    }

    private void UpdateChatList(Dictionary<uint, NanoChatRecipient> recipients)
    {
        ChatList.RemoveAllChildren();
        _recipients = recipients;

        NoChatsLabel.Visible = recipients.Count == 0;
        if (NoChatsLabel.Parent != ChatList)
        {
            NoChatsLabel.Parent?.RemoveChild(NoChatsLabel);
            ChatList.AddChild(NoChatsLabel);
        }

        foreach (var (number, recipient) in recipients.OrderBy(r => r.Value.Name))
        {
            var entry = new NanoChatEntry(_maxNameLength, _maxIdJobLength);
            // For pending chat selection, always show it as selected even if unconfirmed
            var isSelected = (_pendingChat == number) || (_pendingChat == null && _currentChat == number);
            entry.SetRecipient(recipient, number, isSelected);
            entry.OnPressed += SelectChat;
            ChatList.AddChild(entry);
        }
    }

    private void UpdateCurrentChat()
    {
        var activeChat = _pendingChat ?? _currentChat;
        var hasActiveChat = activeChat != null;

        var isGroupChat = false;
        var canManageGroup = false;
        NanoChatRecipient recipient = default;
        var hasRecipient = false;

        if (hasActiveChat && activeChat != null && _recipients.TryGetValue(activeChat.Value, out recipient))
        {
            hasRecipient = true;
            isGroupChat = recipient.IsGroup;
            canManageGroup = isGroupChat && (recipient.CreatorId == _ownNumber || recipient.Admins?.Contains(_ownNumber) == true);
        }

        // Update UI state
        MessagesScroll.Visible = hasActiveChat;
        CurrentChatName.Visible = !hasActiveChat;
        MessageInputContainer.Visible = hasActiveChat;
        DeleteChatButton.Visible = hasActiveChat;
        EditChatButton.Visible = hasActiveChat && !isGroupChat;
        DeleteChatButton.Disabled = !hasActiveChat;


        InviteToGroupButton.Visible = canManageGroup;
        ViewMembersButton.Visible = isGroupChat;

        if (hasRecipient)
        {
            if (isGroupChat)
            {
                CurrentChatName.Text = recipient.Name;
            }
            else
            {
                CurrentChatName.Text = recipient.Name + (string.IsNullOrEmpty(recipient.JobTitle) ? "" : $" ({recipient.JobTitle})");
            }
        }
        else
        {
            CurrentChatName.Text = Loc.GetString("nano-chat-select-chat");
        }
    }

    private void UpdateMessages(Dictionary<uint, List<NanoChatMessage>> messages)
    {
        _messages = messages;
        MessageList.RemoveAllChildren();

        var activeChat = _pendingChat ?? _currentChat;
        if (activeChat == null || !messages.TryGetValue(activeChat.Value, out var chatMessages))
            return;

        var isGroupChat = _recipients.TryGetValue(activeChat.Value, out var recipient) && recipient.IsGroup;
        foreach (var message in chatMessages)
        {
            var messageBubble = new NanoChatMessageBubble();
            var isOwnMessage = message.SenderId == _ownNumber;

            // For group chats, show sender name for other people's messages
            string? senderName = null;
            if (isGroupChat && !isOwnMessage)
            {
                // Try to get sender name from contacts first, then recipients
                if (_recipients.TryGetValue(message.SenderId, out var senderRecipient))
                {
                    senderName = senderRecipient.Name;
                }

                // If not in recipients, try contacts list (station-wide directory)
                if (senderName == null && _contacts != null)
                {
                    var contact = _contacts.FirstOrDefault(c => c.Number == message.SenderId);
                    if (contact.Number != 0)
                        senderName = contact.Name;
                }

                // Fallback to "Unknown" with number if name not found
                if (senderName == null)
                {
                    senderName = $"{Loc.GetString("nano-chat-unknown-sender")}#{message.SenderId:D4}";
                }
            }

            messageBubble.SetMessage(message, isOwnMessage, senderName, isGroupChat && !isOwnMessage);

            // Add spacing between messages
            if (MessageList.ChildCount > 0)
                MessageList.AddChild(new Control { Name = "MessagePadding", MinSize = new Vector2(0, 4) });

            MessageList.AddChild(messageBubble);
        }

        MessageList.InvalidateMeasure();
        MessagesScroll.InvalidateMeasure();

        // Scroll to bottom after messages are added
        if (MessageList.Parent is ScrollContainer scroll)
            scroll.SetScrollValue(new Vector2(0, float.MaxValue));
    }

    private void UpdateMuteButton()
    {
        if (BellMutedIcon != null)
            BellMutedIcon.Visible = _notificationsMuted;
    }

    private void UpdateMuteChatButton()
    {
        if (BellMutedIconContact != null)
            BellMutedIconContact.Visible = _currentChat is uint currentChat && _mutedChats.Contains(currentChat);
    }

    private void UpdateListNumber()
    {
        if (ListNumberButton != null)
            ListNumberButton.Pressed = _listNumber;
    }

    public void UpdateState(NanoChatUiState state)
    {
        _ownNumber = state.OwnNumber;
        _notificationsMuted = state.NotificationsMuted;
        _listNumber = state.ListNumber;
        _mutedChats = state.MutedChats;
        _contacts = state.Contacts;
        OwnNumberLabel.Text = $"#{state.OwnNumber:D4}";
        UpdateMuteButton();
        UpdateListNumber();

        // Update new chat button state based on recipient limit
        var atLimit = state.Recipients.Count >= state.MaxRecipients;
        NewChatButton.Disabled = atLimit;
        NewChatButton.ToolTip = atLimit
            ? Loc.GetString("nano-chat-max-recipients")
            : Loc.GetString("nano-chat-new-chat");

        // First handle pending chat resolution if we have one
        if (_pendingChat != null)
        {
            if (_pendingChat == state.CurrentChat)
                _currentChat = _pendingChat; // Server confirmed our selection

            _pendingChat = null; // Clear pending either way
        }

        // No pending chat or it was just cleared, update current directly
        if (_pendingChat == null)
            _currentChat = state.CurrentChat;

        // Update recipients first, then update UI that depends on it
        UpdateChatList(state.Recipients);
        UpdateMessages(state.Messages);
        UpdateCurrentChat();
        UpdateMuteChatButton();
        LookupView.UpdateContactList(state);

        RefreshOpenPopups();
    }
}
